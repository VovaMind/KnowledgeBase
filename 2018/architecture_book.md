# Конспект книги <чистая архитектура> Роберта Мартина

## Введение

Стоимость разработки/поддержки может расти очень сильно с течением времени жизни продукта.

Архитектура важна и нужно бороться за то, чтобы иметь хорошую архитектуру. Это важно как на дистанции, так и в моменте.

Важно как программа написина и не так важно что она делает. Другими словами, хорошо написанную программу всегда можно допилить.

## Парадигмы

Парадигмы вводят различные ограничения для программ. Кажется, что новых парадигм не предвидится.

Структурное (процедурное?) программирование накладывает ограничения на прямую передачу управления. Оно помогает создавать программные единицы, которые можно проверять. Помогает лучше структурировать программу.

ООП. Накладывает ограничения на косвенную передачу управления. Инкапсуляция возможна и в процедурном программировании. Наследование также реализуемо. Полиморфизм - это сильная сторона. Он помогает инвертировать зависимости в коде. ООП дает контроль над зависимостями в коде и помогает изолировать низкоуровневые детали.

Функциональное программирование накладывает ограничение на присваивание.

## Принципы дизайна

Принцип единой ответственности (SRP, single responsobility principle). Модуль должен отвечать ровно за одного актора. Пример нарушения: метод который реализует логику как для HR, так и для бухгалтерии. 

Принцип открытости/закрытости (OCP, open-closed principle). Программные сущности должны быть открыты для расширения и закрыты для изменения. Цель - обезопасить систему от изменений и сделать систему легко расширяемой.

Принцип подстановки Барбары Лисков. Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Принцип разделения интерфейсов.

Принцип инверсии зависимости (DIP, dependency inversion principle). В гибких системах зависимости направлены на абстракции, а не на конкретные реализации.

## Принципы огранизации компонентов

REP (reuse/release equivalence principle) - принцип эквивалености повторного использования. Единица повторного использования есть единица выпуска.

CCP (common closure principle) - принцип согласованного изменения. В один компонент должны включаться классы изменяющиеся по одним причинам в одно время. В разные компоненты влючаются классы, которые изменяются в разное время по разным причинам.

CRP (common reuse principle) - не вынуждайте пользователей компонента зависеть от того, что им не нужно.

Невозможно соблюдать все три принципа по максимуму, так как они друг другу немного противоречят. Нужен баланс.

На ранних этапах CCP важнее, чем REP. Баланс может постоянно смещаться. Нужно отслеживать ситуацию и корректировать по ходу.

Проблемы:

*  REP+CCP - слишком много ненужных выпусков.
*  REP+CRP - изменения затрагивают слишком много компонентов.
*  CCP+CRP - усложняется повторное использование.

В проектах не должно быть циклических зависимостей.

Зависимости должны быть направлены в сторону устойчивости! Можно определить (примерно) неустойчивость как I = f_out / (f_out+f_in). f_in - число входящих зависимостей, f_out - число исходящих. Если все зависят от X, то он устойчивый, если X от всех зависит, то он неустойчивый. 

Не все компоненты должны быть устойчивыми. Абстрактные компоненты. Устойчивость компонента пропорциональна его абстрактности (принцип устойчивой абстракции). Мера абстрактности: n_a / n_c. Плоскоть с неустойчивостью и абстрактностью. Компоненты должны лежать на диагонали (0, 1)-(1,0). Близко к (0, 0) находится "зона боли" - тяжело менять. (1, 1) - "зона бесполезности", ненужные абстракции. Можно считать расстояния (распределения растояний) до основной диагонали. Это примерный подход, не абсолютная истина. Но основные моменты он отражает.

## Архитектура

TBD
