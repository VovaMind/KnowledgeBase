# Конспект книги <чистая архитектура> Роберта Мартина

## Введение

Стоимость разработки/поддержки может расти очень сильно с течением времени жизни продукта.

Архитектура важна и нужно бороться за то, чтобы иметь хорошую архитектуру. Это важно как на дистанции, так и в моменте.

Важно как программа написина и не так важно что она делает. Другими словами, хорошо написанную программу всегда можно допилить.

## Парадигмы

Парадигмы вводят различные ограничения для программ. Кажется, что новых парадигм не предвидится.

Структурное (процедурное?) программирование накладывает ограничения на прямую передачу управления. Оно помогает создавать программные единицы, которые можно проверять. Помогает лучше структурировать программу.

ООП. Накладывает ограничения на косвенную передачу управления. Инкапсуляция возможна и в процедурном программировании. Наследование также реализуемо. Полиморфизм - это сильная сторона. Он помогает инвертировать зависимости в коде. ООП дает контроль над зависимостями в коде и помогает изолировать низкоуровневые детали.

Функциональное программирование накладывает ограничение на присваивание.

## Принципы дизайна

Принцип единой ответственности (SRP, single responsobility principle). Модуль должен отвечать ровно за одного актора. Пример нарушения: метод который реализует логику как для HR, так и для бухгалтерии. 

Принцип открытости/закрытости (OCP, open-closed principle). Программные сущности должны быть открыты для расширения и закрыты для изменения. Цель - обезопасить систему от изменений и сделать систему легко расширяемой.

Принцип подстановки Барбары Лисков. Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Принцип разделения интерфейсов.

Принцип инверсии зависимости (DIP, dependency inversion principle). В гибких системах зависимости направлены на абстракции, а не на конкретные реализации.

## Принципы огранизации компонентов

REP (reuse/release equivalence principle) - принцип эквивалености повторного использования. Единица повторного использования есть единица выпуска.

CCP (common closure principle) - принцип согласованного изменения. В один компонент должны включаться классы изменяющиеся по одним причинам в одно время. В разные компоненты влючаются классы, которые изменяются в разное время по разным причинам.

CRP (common reuse principle) - не вынуждайте пользователей компонента зависеть от того, что им не нужно.

Невозможно соблюдать все три принципа по максимуму, так как они друг другу немного противоречят. Нужен баланс.

На ранних этапах CCP важнее, чем REP. Баланс может постоянно смещаться. Нужно отслеживать ситуацию и корректировать по ходу.

Проблемы:

*  REP+CCP - слишком много ненужных выпусков.
*  REP+CRP - изменения затрагивают слишком много компонентов.
*  CCP+CRP - усложняется повторное использование.

В проектах не должно быть циклических зависимостей.

Зависимости должны быть направлены в сторону устойчивости! Можно определить (примерно) неустойчивость как I = f_out / (f_out+f_in). f_in - число входящих зависимостей, f_out - число исходящих. Если все зависят от X, то он устойчивый, если X от всех зависит, то он неустойчивый. 

Не все компоненты должны быть устойчивыми. Абстрактные компоненты. Устойчивость компонента пропорциональна его абстрактности (принцип устойчивой абстракции). Мера абстрактности: n_a / n_c. Плоскоть с неустойчивостью и абстрактностью. Компоненты должны лежать на диагонали (0, 1)-(1,0). Близко к (0, 0) находится "зона боли" - тяжело менять. (1, 1) - "зона бесполезности", ненужные абстракции. Можно считать расстояния (распределения растояний) до основной диагонали. Это примерный подход, не абсолютная истина. Но основные моменты он отражает.

## Архитектура

Нужно отделять детали от политики. Политика не должна зависеть от деталей. В хорошей архитектуре нужно отложить решение о деталях на как можно более поздний срок.

Разделение на компоненты - это сложная задача. И оно будет меняться со временем. Нужно предвидеть изменения и стремиться к упощению.

Нужно проводить границы так, чтобы зависимости указывали в сторону бизнес-правил. Зависимости идут от низкоуровневых деталей к высокоуровневым абстракциям. Тут нужно использовать принцип устойчивой абстракции и принцип инверсии зависимостей.

Бывают разные типы границ - локальные (недорогие в пересечении), границы с задежками (разные сервисы). Есть также границы подключаемых модулей. Есть несколько стратегий для границ и нужно быть аккуратным при работе с ними.

Бизнес правила - это причина существования системы. Они состовляют основу. Они должны быть свободны от зависимостей от деталей (UI, база данных, конкретный фреймворк и тэдэ). Реализация бизнес правил - независимый код, готовый к многократному использованию. Ядро - это сущности, вокруг них идут варианты использования - это суть бизнес правил.

Архитектура должна рассказывать о системе, а не об использованных фреймворках. С первого взгляда должны быть понятны задачи системы. Варианты использования должны быть понятны без оглядки на предостовляемые услуги. Архитектура должна "кричать" о своем назначении. Решение о деталях нужно отложить на как можно более поздний срок.

Чистая архитектура (концентрические круги):

*  Сущности.
*  Варианты использования.
*  Контроллеры, шлюзы, презентаторы.
*  Веб, UI, API, устройства.

Зависимости должны быть направлены внутрь.

Шаблон "скомный объект". Раздленине логики на две части - основная (большая), которую можно протестировать и скормная (маленькая), которую сложно тестировать. View/presenter пример. View - это UI, который сложно тестировать и нужно его сделать максимально простым. Presenter - получает данные от приложения и строит максимально простое UI-specific представление данных (цвет кнопки и тэдэ). Presenter можно протестировать. Шлюз к базе данных - тоже пример такого объекта, преобразование данных тоже пример.

Бывают неполные границы. Например, фасад, разделить на уровне кода но оставить в одном компоненте, "резерв" под выделение стратегии. Нужно понять где и как проводить границу и нужно ли реализовывать ее полностью или частично. 

Принцип YAGNI (you aren't going to need it), нужно быть аккуратным с ним! Нужно наблюдать за развитием системы и отмечать места для новых границ. 

Главный компонент (main) - собирает все воедино. Он самый грязный и нетестируемый из компонентов. Main - это плагин для приложения. Можно иметь много таких плагинов: разработка/тестирование/эксплуатация/для юресдцикции/для конкретного кллиента/для локализации и тэдэ. Нужно думать о main как о плагине за архитектурной границей.

TBD
